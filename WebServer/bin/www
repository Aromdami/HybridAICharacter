//최종 빌드 시 www.js 에서 www로 파일명칭 변경할 것
const express = require('express')
const app = express()
var debug = require('debug')('webserver:server');
var http = require('http');
var port = 3000;
var server = http.createServer(app);

var regUsers = {};
var liveUsers = {};   

app.use(express.static('public'))

/* IO 파트 추가*/
var io = require('socket.io')(server);

//접속 유무 확인, 채팅 전송
io.on('connection', (socket) => {
  console.log('사용자 접속 확인 (번호: ' + socket.id + ')');

  //간이 로그인, 접속
  socket.on('access', function(name){
    const id = name + '';
    liveUsers[id] = {room: 1, socketID: socket.id, name:id};
    socket.join('room1');
    updateUser(0, 1, id);

    console.log('사용자 로그인 확인 (아이디: ' + id + ') (번호: ' + socket.id + ')');
  });

  //채팅 전송
  socket.on('chat message', function(message, name, room){ 
    const msg = name + ': ' + message;
    console.log(msg);
    socket.to('room' + room).emit('chat message', msg);
  });


  //채팅방 들어감
  socket.on('join chat', function(info)
  {
    let usrname = getUsrNameSID(socket.id);
    let prv = liveUsers[usrname].room;
    let nxt = info.room;
    socket.leave('room' + prv);
    socket.join('room' + nxt);
    

    liveUsers[usrname].room = info.room; 

    updateUser(prv, nxt, socket.id);
  });
  

  socket.on('disconnect', function(){
    console.log('사용자 접속 종료');

    let id = getUsrNameSID(socket.id);
    let room = liveUsers[id].room;
    delete liveUsers[id];
    
    updateUser(room, 0, id);
  }); 

  //서버 고유 id로 사용자 이름 찾기
  function getUsrNameSID(id)
  {
    return Object.keys(liveUsers).find(key => liveUsers[key].socketID === id);
  }

  //방에 접속한 사용자 정보 확인
  function roomUserList(num)
  {
    let usrLog = [];
    Object.keys(liveUsers).forEach(
      (i) => {
        if (liveUsers[i].room === num)
        {
          
          usrLog.push({
            socketID: liveUsers[i].socketID,
            name: i
          });
        }
      });

    return usrLog;
  }

  function updateUser(prv, nxt, id)
  {
    if (prv != 0)
    {
      socket.to('room' + prv).emit('users', roomUserList(prv));
      socket.to('room' + prv).emit('leave chat', id);
    }
    if (nxt != 0)
    {
      socket.to('room' + nxt).emit('users', roomUserList(nxt));
      socket.to('room' + nxt).emit('enter chat', id);
      console.log("logging ");
    }
  }

});



/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
